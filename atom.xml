<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://machangxin.github.io</id>
    <title>Auk&apos;s blog</title>
    <updated>2019-11-28T03:11:04.037Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://machangxin.github.io"/>
    <link rel="self" href="https://machangxin.github.io/atom.xml"/>
    <subtitle>我是一只小小鸟</subtitle>
    <logo>https://machangxin.github.io/images/avatar.png</logo>
    <icon>https://machangxin.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Auk&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[简单的代码生成程序]]></title>
        <id>https://machangxin.github.io/post/49gvoHq33</id>
        <link href="https://machangxin.github.io/post/49gvoHq33">
        </link>
        <updated>2019-11-28T03:09:27.000Z</updated>
        <content type="html"><![CDATA[<p>通过三地址代码序列生成计算机的目标代码,在生成算法中,对寄存器的使用顺序为:寄存器中存有 &gt; 空寄存器 &gt; 内存中存有 &gt; 以后不再使用 &gt; 最远距离使用</p>
<p><strong>输入格式:</strong><br>
给定输出的三地址代码的个数和寄存器的个数.所有的变量为大写字母,寄存器的数量不超过9</p>
<p><strong>输出格式:</strong><br>
参照示例格式输出,不需要将最后的寄存器中的值写回内存<br>
不再使用变量不用写回内存</p>
<p><strong>输入样例:</strong><br>
4 2<br>
T:=A-B<br>
U:=A-C<br>
V:=T+U<br>
W:=V+U<br>
<strong>输出样例:</strong><br>
LD R0, A<br>
SUB R0, B<br>
LD R1, A<br>
SUB R1, C<br>
ADD R0, R1<br>
ADD R0, R1</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m,nr=0;
string s[100];
char r[15];
int inr(char c){
    for(int i=0;i&lt;m;i++)if(r[i]==c) return i;
    return -1;
}
int gul(int pos,char c){
    for(int i=pos;i&lt;=n;i++)if(s[i][3]==c||s[i][5]==c)return i;
    return n+1;
}
int getr(int pos){
    if(nr&lt;m) return nr++;
    int ans=-1,maxx=-1;
    for(int i=0;i&lt;m;i++){
        int ne= gul(pos,r[i]);
        if(ne&gt;maxx) maxx=ne,ans=i;
    }
    return ans;
}
void printop(char c){
    if(c=='+') printf(&quot;ADD &quot;);
    if(c=='*') printf(&quot;MUL &quot;);
    if(c=='-') printf(&quot;SUB &quot;);
}
void printr(char c){
    int pos= inr(c);
    if(pos==-1)printf(&quot;%c\n&quot;,c);
    else printf(&quot;R%d\n&quot;,pos);
}
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++) cin&gt;&gt;s[i];
    for(int i=1;i&lt;=n;i++){
        int pos = inr(s[i][3]);
        if(pos==-1){
            pos=getr(i);
            if(r[pos]&amp;&amp;gul(i,r[pos])&lt;n+1)
                printf(&quot;ST R%d, %c\n&quot;,pos,r[pos]);
            printf(&quot;LD R%d, %c\n&quot;,pos,s[i][3]);
            r[pos]=s[i][3];
        }
        printop(s[i][4]);
        printf(&quot;R%d, &quot;,pos);
        printr(s[i][5]);
        r[pos]=s[i][0];
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[翻译布尔表达式]]></title>
        <id>https://machangxin.github.io/post/d_CBRYM0E</id>
        <link href="https://machangxin.github.io/post/d_CBRYM0E">
        </link>
        <updated>2019-11-28T03:08:32.000Z</updated>
        <content type="html"><![CDATA[<p>大家都学过了布尔表达式的翻译，其中有一个拉链－回填技术，这次我们就练习这个技术。<br>
注意，在布尔表达式中，“并且”运算的优先级是要高于“或者”运算的。</p>
<p><strong>输入格式:</strong><br>
输入为一行字符串，例如： a &lt; b or c &lt; d and e &lt; f<br>
每个符号都用空格间隔。<br>
其中逻辑运算符包含 and 和 or ， 关系运算符包含 &lt; 、&gt; 、&lt;= 、 &gt;= 、== 、 != 。</p>
<p><strong>输出格式:</strong><br>
假链跳到０，真链跳到１，表达式序号从100开始排。</p>
<p><strong>输入样例1:</strong><br>
a &lt; b or c &lt; d and e &lt; f<br>
<strong>输出样例1:</strong><br>
100(j&lt;,a,b,1)<br>
101(j,<em>,</em>,102)<br>
102(j&lt;,c,d,104)<br>
103(j,<em>,</em>,0)<br>
104(j&lt;,e,f,100)<br>
105(j,<em>,</em>,103)<br>
<strong>输入样例2:</strong><br>
a &lt; b and c &gt; d or e &gt; f<br>
<strong>输出样例2:</strong><br>
100(j&lt;,a,b,102)<br>
101(j,<em>,</em>,104)<br>
102(j&gt;,c,d,1)<br>
103(j,<em>,</em>,101)<br>
104(j&gt;,e,f,102)<br>
105(j,<em>,</em>,0)</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
#define pr ans[1].c_str(),ans[0].c_str(),ans[2].c_str()
int main()
{
    string x,xx,s[1000];
    getline(cin,xx);
    xx+=&quot; end&quot;;
    int h=1,hh,ix=100,num=0,ff[1000],t=1,f=0,f2=0;
    vector&lt;string&gt;ans;
    bool flag=0;
    stringstream ss(xx);
    while(ss&gt;&gt;x)
    {
        s[++num]=x;
    }
    for(int i=1; i&lt;=num; i++){
        if(s[i]==&quot;or&quot;||s[i]==&quot;and&quot;)
            h++;
    }

    for(int i=num; i&gt;=1; i--)
    {
        if(s[i]==&quot;or&quot;)
            flag=1,h--,hh=h;
        else if(s[i]==&quot;and&quot;)
        {
            h--;
            if(flag)
            {
                ff[i]=100+2*hh;
            }
        }
    }
    for(int i=1; i&lt;=num; i++)
    {
        x=s[i];
        if(x==&quot;or&quot;)
        {
            printf(&quot;%d(j%s,%s,%s,%d)\n&quot;,ix,pr,t);
            t=ix++;
            if(!f2)
                printf(&quot;%d(j,_,_,%d)\n&quot;,ix,ix+1);
            else
                printf(&quot;%d(j,_,_,%d)\n&quot;,ix,f2),f2=0;
            ix++;
            ans.clear();
        }
        else if(x==&quot;and&quot;)
        {
            printf(&quot;%d(j%s,%s,%s,%d)\n&quot;,ix,pr,ix+2);
            ix++;
            if(!ff[i])
                printf(&quot;%d(j,_,_,%d)\n&quot;,ix,f),f=ix;
            else
                printf(&quot;%d(j,_,_,%d)\n&quot;,ix,!f2? ff[i]:f2),f2=ix;
            ix++;
            ans.clear();
        }
        else if(x==&quot;end&quot;)
        {
            printf(&quot;%d(j%s,%s,%s,%d)\n&quot;,ix++,pr,t);
            printf(&quot;%d(j,_,_,%d)\n&quot;,ix,f);
        }
        else
            ans.push_back(x);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DAG图优化]]></title>
        <id>https://machangxin.github.io/post/15RsiSbeQ</id>
        <link href="https://machangxin.github.io/post/15RsiSbeQ">
        </link>
        <updated>2019-11-28T03:07:08.000Z</updated>
        <content type="html"><![CDATA[<p>大家都学过了代码优化，其中有一个DAG优化，这次我们就练习这个操作。</p>
<p><strong>输入格式:</strong><br>
输入第一行为一个整数ｎ(n &lt; 100)，表示该组输入的表达式的个数。<br>
之后ｎ行为表达式，每个变量为一个字母，表达式仅包括二元运算 + - * / 。<br>
例如：A=B+C 。</p>
<p><strong>输出格式:</strong><br>
通过构造DAG图，进行代码优化，只需要保留AB，删除无用变量，删除变量时，尽量保留最早出现的变量。<br>
PS:保证AB的值不同</p>
<p><strong>输入样例:</strong><br>
3<br>
A=B+C<br>
B=B+B<br>
A=C+C<br>
<strong>输出样例:</strong><br>
B=B+B<br>
A=C+C</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
struct{
    char id;
    int l=-1,r=-1;
    vector&lt;char&gt;v;
}node[105],ll,rr;
int n,cnt=0;
string s,ans[100];
bool f[100];
bool find(int i,char c){
    for(char j:node[i].v) if(j==c) return 1;
    return 0;
}
int add(char c){
    for(int i=cnt;i&gt;=1;i--)
        if(node[i].id==c||find(i,c)) return i;
    node[++cnt].id=c;
    return cnt;
}
void addf(char c,char op,int l,int r){
    for(int i=cnt;i&gt;=1;i--){
        if(node[i].l==l&amp;&amp;node[i].r==r&amp;&amp;node[i].id==op){
            node[i].v.push_back(c);
            return ;
        }
    }
    node[++cnt].id=op;
    node[cnt].v.push_back(c);
    node[cnt].l=l;
    node[cnt].r=r;
    return ;
}
void dfs(int i){
    if(node[i].l!=-1){
        f[i]=1;
        dfs(node[i].l);
        dfs(node[i].r);
    }
}
int main(){
    cin&gt;&gt;n;
    while(n--){
        cin&gt;&gt;s;
        int l= add(s[2]),r = add(s[4]);
        addf(s[0],s[3],l,r);
    }
    for(int i=1;i&lt;=cnt;i++)
    if(node[i].l!=-1){
        ans[i]+=node[i].v[0];
        ans[i]+='=';
        ll=node[node[i].l];
        rr=node[node[i].r];
        ans[i]+=ll.v.size()? ll.v[0]:ll.id;
        ans[i]+=node[i].id;
        ans[i]+=rr.v.size()? rr.v[0]:rr.id;
    }
    for(int i=cnt;i&gt;=1;i--){
        if(ans[i][0]=='A'){
            dfs(i);
            break;
        }
    }

    for(int i=cnt;i&gt;=1;i--){
        if(ans[i][0]=='B'){
            dfs(i);
            break;
        }
    }
    for(int i=1;i&lt;=cnt;i++)
        if(f[i])
        cout&lt;&lt;ans[i]&lt;&lt;endl;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[小C语言--词法分析程序]]></title>
        <id>https://machangxin.github.io/post/qb9rLP5a_</id>
        <link href="https://machangxin.github.io/post/qb9rLP5a_">
        </link>
        <updated>2019-11-28T03:05:29.000Z</updated>
        <content type="html"><![CDATA[<p>小C语言文法</p>
<p>&lt;程序&gt;→(){&lt;声明序列&gt;&lt;语句序列&gt;}<br>
&lt;声明序列&gt;→&lt;声明序列&gt;&lt;声明语句&gt;|&lt;声明语句&gt;|&lt;空&gt;<br>
&lt;声明语句&gt;→&lt;标识符表&gt;;<br>
&lt;标识符表&gt;→&lt;标识符&gt;,&lt;标识符表&gt;|&lt;标识符&gt;<br>
&lt;语句序列&gt;→&lt;语句序列&gt;&lt;语句&gt;|&lt;语句&gt;<br>
&lt;语句&gt;→&lt; if语句&gt;|&lt; while语句&gt;|&lt; for语句&gt;|&lt;复合语句&gt;|&lt;赋值语句&gt;<br>
&lt; if语句&gt;→&lt; if关键字&gt;(&lt;表达式&gt;)&lt;复合语句&gt;|(&lt;表达式&gt;)&lt;复合语句&gt;&lt; else关键字&gt;&lt;复合语句&gt;<br>
&lt; while语句&gt;→&lt; while关键字&gt;(&lt;表达式&gt;)&lt;复合语句&gt;<br>
&lt; for语句&gt;→&lt; for关键字&gt;(&lt;表达式&gt;;&lt;表达式&gt;;&lt;表达式&gt;)&lt;复合语句&gt;<br>
&lt;复合语句&gt;→{&lt;语句序列&gt;}<br>
&lt;赋值语句&gt;→&lt;表达式&gt;;<br>
&lt;表达式&gt;→&lt;标识符&gt;=&lt;算数表达式&gt;|&lt;布尔表达式&gt;<br>
&lt;布尔表达式&gt;→&lt;算数表达式&gt; |&lt;算数表达式&gt;&lt;关系运算符&gt;&lt;算数表达式&gt;<br>
&lt;关系运算符&gt;→&gt;|&lt;|&gt;=|&lt;=|==|!=<br>
&lt;算数表达式&gt;→&lt;算数表达式&gt;+&lt;项&gt;|&lt;算数表达式&gt;-&lt;项&gt;|&lt;项&gt;<br>
&lt;项&gt;→&lt;项&gt;*&lt;因子&gt;|&lt;项&gt;/&lt;因子&gt;|&lt;因子&gt;<br>
&lt;因子&gt;→&lt;标识符&gt;|&lt;无符号整数&gt;|(&lt;算数表达式&gt;)<br>
&lt;标识符&gt;→&lt;字母&gt;|&lt;标识符&gt;&lt;字母&gt;|&lt;标识符&gt;&lt;数字&gt;<br>
&lt;无符号整数&gt;→&lt;数字&gt;|&lt;无符号整数&gt;&lt;数字&gt;<br>
&lt;字母&gt;→a|b|…|z|A|B|…|Z<br>
&lt;数字&gt;→0|1|2|3|4|5|6|7|8|9<br>
&lt; main关键字&gt;→main<br>
&lt; if关键字&gt;→if<br>
&lt; else关键字&gt;→else<br>
&lt; for关键字&gt;→for<br>
&lt; while关键字&gt;→while<br>
&lt; int关键字&gt;→int<br>
每行单词数不超过10个<br>
小C语言文法如上，现在我们对小C语言写的一个源程序进行词法分析，分析出关键字、自定义标识符、整数、界符和运算符。<br>
关键字：main if else for while int<br>
自定义标识符：除关键字外的标识符<br>
整数：无符号整数<br>
界符：{ } ( ) , ;<br>
运算符：= + - * / &lt; &lt;= &gt; &gt;= == !=<br>
<strong>输入格式:</strong><br>
输入一个小C语言源程序，源程序长度不超过2000个字符，保证输入合法。</p>
<p><strong>输出格式:</strong><br>
按照源程序中单词出现顺序输出，输出二元组形式的单词串。<br>
(单词种类,单词值)<br>
单词一共5个种类：<br>
关键字：用keyword表示<br>
自定义标识符：用identifier表示<br>
整数：用integer表示<br>
界符：用boundary表示<br>
运算符：用operator表示<br>
每种单词值用该单词的符号串表示。<br>
<strong>输入样例:</strong></p>
<pre><code>main() 
{
    int a, b;
    if(a == 10)
    {
        a = b;
    }
}
</code></pre>
<p><strong>输出样例:</strong><br>
(keyword,main)<br>
(boundary,()<br>
(boundary,))<br>
(boundary,{)<br>
(keyword,int)<br>
(identifier,a)<br>
(boundary,,)<br>
(identifier,b)<br>
(boundary,😉<br>
(keyword,if)<br>
(boundary,()<br>
(identifier,a)<br>
(operator,==)<br>
(integer,10)<br>
(boundary,))<br>
(boundary,{)<br>
(identifier,a)<br>
(operator,=)<br>
(identifier,b)<br>
(boundary,😉<br>
(boundary,})<br>
(boundary,})</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
map&lt;char,bool&gt;b,o;
map&lt;string,bool&gt;key;
void pd(string s){
    if(s==&quot;&quot;||s==&quot; &quot;) return ;
    if(s[0]&gt;=48&amp;&amp;s[0]&lt;=57)
        printf(&quot;(integer,%s)\n&quot;,s.c_str());
    else if(key[s]) printf(&quot;(keyword,%s)\n&quot;,s.c_str());
        else printf(&quot;(identifier,%s)\n&quot;,s.c_str());
}
int main(){
    char bo[]={'{','}','(',')',',',';'};
    char op[]={'/','*','-','+','=','&lt;','&gt;','!'};
    string k[]={&quot;main&quot;,&quot;if&quot;,&quot;else&quot;,&quot;for&quot;,&quot;while&quot;,&quot;int&quot;};
    for(int i=0;i&lt;6;i++) b[bo[i]]=1,key[k[i]]=1;
    for(int i=0;i&lt;8;i++) o[op[i]]=1;
    string ss;
    while(cin&gt;&gt;ss){
        string s;
        for(int i=0;i&lt;ss.length();i++){
            if(b[ss[i]]){
                pd(s),s=&quot;&quot;;
                printf(&quot;(boundary,%c)\n&quot;,ss[i]);
            }
            else if(o[ss[i]]){
                pd(s),s=&quot;&quot;;
                if(i+1&lt;ss.length()&amp;&amp;ss[i+1]=='=')
                    printf(&quot;(operator,%c%c)\n&quot;,ss[i],ss[i+1]),i++;
                else printf(&quot;(operator,%c)\n&quot;,ss[i]);
            }
            else s+=ss[i];
        }
        pd(s);

    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[表达式语法分析——递归子程序法]]></title>
        <id>https://machangxin.github.io/post/cn0cfeQNa</id>
        <link href="https://machangxin.github.io/post/cn0cfeQNa">
        </link>
        <updated>2019-11-28T03:02:21.000Z</updated>
        <content type="html"><![CDATA[<p>递归子程序法是一种确定的自顶向下语法分析方法，要求文法是LL(1)文法。它的实现思想是对应文法中每个非终结符编写一个递归过程，每个过程的功能是识别由该非终结符推出的串，当某非终结符的产生式有多个候选式时能够按LL(1)形式唯一地确定选择某个候选式进行推导。请根据下面的表达式LL(1)文法，构造递归子程序，完成对表达式的语法分析。<br>
表达式文法如下：<br>
E→TG<br>
G→+TG | ε<br>
T→FS<br>
S→<em>FS | ε<br>
F→(E) | i<br>
对于给定的输入串（长度不超过50个符号），请输出分析过程中用到的所有产生式，并指明该输入串是否为该文法能生成的表达式,输出共11行，前10行每行两个数据用空格隔开，表示推导时所用产生式顺序号（从0开始），最后一行是accept，表示i+i</em>i是文法能生成的合法表达式。注：其中&amp;符号代表文法中的ε符号。 例如：<br>
i+i*i是文法能生成的一个表达式,输出格式如下：<br>
0 E--&gt;TG<br>
1 T--&gt;FS<br>
2 F--&gt;i<br>
3 S--&gt;&amp;<br>
4 G--&gt;+TG<br>
5 T--&gt;FS<br>
6 F--&gt;i<br>
7 S--&gt;*FS<br>
8 F--&gt;i<br>
9 S--&gt;&amp;<br>
10 G--&gt;&amp;<br>
accept</p>
<p>i@i不是文法能生成的表达式，输出共5行，前5行每行两个数据用空格隔开，表示推导时所用产生式序号（从0开始），最后一行是error，表示i@i不是文法能生成的表达式。@不是合法的文法符号，输出格式举例：<br>
0 E--&gt;TG<br>
1 T--&gt;FS<br>
2 F--&gt;i<br>
3 S--&gt;&amp;<br>
4 G--&gt;&amp;<br>
error</p>
<p>(i+i*i不是文法能生成的表达式，存在括号不匹配的语法错误，输出格式举例：<br>
0 E--&gt;TG<br>
1 T--&gt;FS<br>
2 F--&gt;(E)<br>
3 E--&gt;TG<br>
4 T--&gt;FS<br>
5 F--&gt;i<br>
6 S--&gt;&amp;<br>
7 G--&gt;+TG<br>
8 T--&gt;FS<br>
9 F--&gt;i<br>
10 S--&gt;*FS<br>
11 F--&gt;i<br>
12 S--&gt;&amp;<br>
13 G--&gt;&amp;<br>
error<br>
<strong>输入格式:</strong><br>
输入数据只有一行，代表待分析的符号串，以#号结束。</p>
<p><strong>输出格式:</strong><br>
输出推导过程中所有的产生式，按照使用顺序给出。输出详细说明见题目描述中的例子。</p>
<p><strong>输入样例:</strong><br>
i+i*i#<br>
<strong>输出样例:</strong><br>
在这里给出相应的输出。例如：<br>
0 E--&gt;TG<br>
1 T--&gt;FS<br>
2 F--&gt;i<br>
3 S--&gt;&amp;<br>
4 G--&gt;+TG<br>
5 T--&gt;FS<br>
6 F--&gt;i<br>
7 S--&gt;*FS<br>
8 F--&gt;i<br>
9 S--&gt;&amp;<br>
10 G--&gt;&amp;<br>
accept</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int ff=0,num=0;
string s;
void e();
void g();
void t();
void S();
void f();
void e()
{
    if(s[ff]=='i'||s[ff]=='(')
        printf(&quot;%d E--&gt;TG\n&quot;,num++);
    t(),g();
}
void t()
{
    if(s[ff]=='i'||s[ff]=='(')
        printf(&quot;%d T--&gt;FS\n&quot;,num++);
    f(),S();
}
void g()
{
    if(s[ff]=='+')
        printf(&quot;%d G--&gt;+TG\n&quot;,num++),ff++,t(),g();
    else
        printf(&quot;%d G--&gt;&amp;\n&quot;,num++);
}
void S()
{
    if(s[ff]=='*')
        printf(&quot;%d S--&gt;*FS\n&quot;,num++),ff++,f(),S();
    else
        printf(&quot;%d S--&gt;&amp;\n&quot;,num++);
}
void f()
{
    if(s[ff]=='(')
    {
        printf(&quot;%d F--&gt;(E)\n&quot;,num++),ff++;
        e();
        if(s[ff]==')')
            ff++;
        else
            printf(&quot;error\n&quot;),exit(0);
    }
    else if(s[ff]=='i')
        printf(&quot;%d F--&gt;i\n&quot;,num++),ff++;
    else
        printf(&quot;error\n&quot;),exit(0);
}

int main()
{
    cin&gt;&gt;s;
    if(s==&quot;#&quot;)
    {
        printf(&quot;error\n&quot;);
        return 0;
    }
    e();
    if(s[ff]=='#')
        printf(&quot;accept\n&quot;);
    else
        printf(&quot;error\n&quot;);
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[杂七杂八小知识]]></title>
        <id>https://machangxin.github.io/post/little  knowledge</id>
        <link href="https://machangxin.github.io/post/little  knowledge">
        </link>
        <updated>2019-11-22T05:49:17.000Z</updated>
        <content type="html"><![CDATA[<p>next()一定要读取到有效字符后才可以结束输入，对输入有效字符之前遇到的空格键、Tab键或Enter键等结束符，next()方法会自动将其去掉，只有在输入有效字符之后，next()方法才将其后输入的空格键、Tab键或Enter键等视为分隔符或结束符。简单地说，next()查找并返回来自此扫描器的下一个完整标记。完整标记的前后是与分隔模式匹配的输入信息，所以next方法不能得到带空格的字符串。而nextLine()方法的结束符只是Enter键，即nextLine()方法返回的是Enter键之前的所有字符，</p>
<p><strong>python</strong><br>
用input输入文件地址时，字符串首部可能出现\u202A，解决方法：</p>
<pre><code>target_name =input(&quot;请输入txt创建地址:\n(例:C:\\Users\马长鑫\Desktop)&quot;)#目标地址
target_name = target_name.replace(u'\u202A', '')
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[洛谷 P1106 删数问题]]></title>
        <id>https://machangxin.github.io/post/洛谷 P1106 删数问题</id>
        <link href="https://machangxin.github.io/post/洛谷 P1106 删数问题">
        </link>
        <updated>2019-11-21T01:40:24.000Z</updated>
        <content type="html"><![CDATA[<p><strong>题目描述</strong><br>
键盘输入一个高精度的正整数N（不超过250位） ，去掉其中任意k个数字后剩下的数字按原左右次序将组成一个新的正整数。编程对给定的N和k，寻找一种方案使得剩下的数字组成的新数最小。</p>
<p><strong>输入格式</strong><br>
n (高精度的正整数) k(需要删除的数字个数)</p>
<p><strong>输出格式</strong><br>
最后剩下的最小数。</p>
<p><strong>输入</strong><br>
175438<br>
4<br>
<strong>输出</strong><br>
13</p>
<hr>
<pre><code>#删除逆序对，例如175，（7,5）是逆序对，那么则删除7，如果无逆序对就直接删最后面的数，注意前导0处理
include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){
    string n;
    int k;
    cin&gt;&gt;n&gt;&gt;k;
    int m=0;
    for(int i=0; i&lt;n.length(); i++)
        if(n[i]&gt;n[i+1]&amp;&amp;m&lt;k){
            n.erase(i,1);
            m++;
            i=-1;
        }
    while(n[0]=='0')n.erase(0,1);
    n.length()!=0? cout&lt;&lt;n.substr(0,n.length()-(k-m))&lt;&lt;endl:cout&lt;&lt;&quot;0&quot;&lt;&lt;endl;
}
</code></pre>
]]></content>
    </entry>
</feed>